## Transcriptomics Module
 
This is a place to record notes of coding happenings during the transcriptomics module
 
# 10/07/2025
 
On the first day of transcrtipomics we learned about the motivation behind and processes involved in the transciptomics worklow. We discussed applications, what questions can be answered, and critical steps involved in processing RNA.
 
We started to run fastp to clean and visualize data quality in our fastq files but encountered some issues with file recognition. To be continued...
 
# 10/09/2025
 
Edited our fastp_tonsa.sh to become fastp_tonsa_take2.sh. This script is more fluent in computer speak and lives: 
`/users/y/o/yoyebami/Projects_Genomics/eco_genomics_2025/transcriptomics/myscripts`


To check the quality of our sequence, we ran fastp_tonsa.take2.sh. Am html file were produced with the quality reports.

To align our sequence to the reference genome, We created a script called salmon_quant.sh. and ran it
`/users/y/o/yoyebami/Projects_Genomics/eco_genomics_2025/transcriptomics/myscripts`

# 10/14/2025
Review mapping rates and saved a mapping rate file

Disscussed factors  that coulkd affect mapping rate. All about 40%
  -Contamination of reads from other taxa that would not map to the reference genome such as algae, microbes
  _ Low RNA quality, Low RNA yield and used low output to prepare RNA
  -Could try with a head command  in the cleaning of the reads in the evnts of primers affect mapping rate
  -Could do a new de novo assembly from these reads (would need to anotation)
  Prepped quant.sh file to import in DESeq2
  
  cd /gpfs1/cl/ecogen/pbio6800/Transcriptomics/transcripts_quant

echo "sample,path" > /gpfs1/cl/ecogen/pbio6800/Transcriptomics/transcripts_quant/samples.csv
for dir in */; do
  sample_name=${dir%/}
  echo "${sample_name},/gpfs1/cl/ecogen/pbio6800/Transcriptomics/transcripts_quant/${sample_name}" >> /gpfs1/cl/ecogen/pbio6800/Transcriptomics/transcripts_quant/samples.csv
done

Now in R studio use the library txiimport to make counts matrix

# Load libraries
library(tximport)
library(readr)

# Path to sample table
samples <- read.csv("/gpfs1/home/X/X/XXX/projects/eco_genomics2025/transcriptomics/myresults/samples.csv")

# Make a named vector of quant.sf file paths
files <- file.path(samples$path, "quant.sf")
names(files) <- samples$sample

# Import Salmon quantifications
txi <- tximport(files, type = "salmon", txOut = TRUE)

# Write counts to txt
write.txt(txi$counts, "/gpfs1/home/y/o/yoyebami/projects/eco_genomics2025/transcriptomics/mydata/counts_matrix.txt")

##DESeq2 start of Data analysis

We copied over metadata file into mydata and then  explore the data through the use of bar graph and histogram using the code below

barplot(colSums(countsTableRound), names.arg=colnames(countsTableRound),cex.names=0.5, las=3,ylim=c(0,21000000)) #change dims
abline(h=mean(colSums(countsTableRound)), col="blue", lwd=2)


### Continuing on 10/18/2025

We checked the quality of the data by sample clustering and visuadlization. The goal of transformation "is to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low

we used the following code chunks

ntd <- normTransform(dds)
meanSdPlot(assay(ntd))
vsd <- vst(dds, blind=FALSE)
meanSdPlot(assay(vsd))


## We created a heatmap of the distance/dissimilarity of the samples using the code bolw

sampleDists <- dist(t(assay(vsd)))

library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$line, vsd$generation, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

Then, We checked outliers using the sampleTree.

sampleTree <- hclust(dist(sampleDists), method="average")

plot(sampleTree, main="Sample clustering to detect outliers", sub="", xlab="",cex.lab=1.5, cex.axis=1.5, cex.main=2)

## Making a PCA from the tutorial

PCA was used to visualize the global expression pattern and optimize the visualization.

vsd <- vst(dds, blind=FALSE)

pcaData <- plotPCA(vsd, intgroup=c("line","generation"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData,"percentVar"))

ggplot(pcaData, aes(PC1, PC2, color=line, shape=generation)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed().
  
  
ggplot(pcaData, aes(PC1, PC2)) +
  geom_point(size=5, stroke = 1, aes(fill=line, shape=generation, alpha = generation)) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  scale_shape_manual(values=c(21,22,23,24), labels = c("G1", "G2","G3", "G4"))+
  #scale_shape_manual(values=c(21,22,23,24) -> circle, square, diamond, triangle
  scale_fill_manual(values=c('#6699CC',"#CC3333"), labels = c("Control", "Treatment"))+
  scale_alpha_manual(values = c(1.0, 0.8, 0.7, 0.3), guide = "none") +
  theme_bw() +
  theme(legend.position = "none") +
  theme(panel.border = element_rect(color = "black", fill = NA, size = 3))+
  theme(text = element_text(size = 20)) +
  theme(legend.title = element_blank()

  
## 10/21/2025

We plot Individual Genes to counts specific top interaction gene (important validatition that the normalization, model is working) using the code chuck below

```{r}
d <-plotCounts(dds, gene="TRINITY_DN148336_c14_g7_i1", intgroup = (c("line","generation")), returnData=TRUE)
d

d$generation <- factor(d$generation, levels = sort(unique(d$generation)))

p <- ggplot(d, aes(x = generation, y = count, color = line, group = line)) +
  theme_minimal() + theme(text = element_text(size=20), panel.grid.major=element_line(colour="grey"))
p <- p + geom_point(position=position_jitter(w=0.2,h=0), size=3, aes(shape = line)) 
p <- p + stat_summary(fun = mean, geom = "point", size=5, alpha=0.7) 
p <- p + stat_summary(fun = mean, geom = "line", size = 1.5, aes(group = line), alpha = 0.8)
p <- p + scale_color_manual(values = c("control" = "blue", "treatment" = "red"))
p
```

Then, We can make an MA plot to determine the the relationship between LFC and magnitude of expression
```{r}
plotMA(resG1_CvT, ylim=c(-5,5))
```

We make a Volcano plot to determine the relationship between LFC and significance of DGE.

Then, we make a Heatmap of top 20 genes sorted by pvalue. We try to look at the variation in gene expression across individual samples among treatment groups

```{r}
topgenes <- head(rownames(resG1_CvT),100)
mat <- assay(vsd)[topgenes,]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(dds)[,c("generation","line")])
pheatmap(mat, annotation_col=df)
pheatmap(mat, annotation_col=df, cluster_cols = F)
```

Then we make plots to explore differentially expressed genes between CvsT across generations.

Finally we can make a Venn or Euler plot to determine the amount of overlap between genes differentially expressed between treatments across generations (G1, G2 and G3)

## 10/23/2025 : Test for functional enrichment, GO analysis

First, we set up differential expression contrasts from DESeq2. 

Then, we look at distributions of our results

Then, we make a density plot with a rugplot below to understand what weâ€™re testing in a functional enrichment test.

Then we ran TopGO. 

We copied the Genes_GO_terms_output.tsv file into mtdata directory.

Then, we evaluate the DESeq2 result for the generation 2 since most differentially expressed genes.

We also visualize the enrichment data using software package REVIGO.

## 10/28/2025: Weighted Gene Correlation Network Analysis (WGCNA) 

For this analysis we used a new rmd file and then create normalized gene expression matrix from DESeq2

To test if any co-expressed modules that we identify are associated with organismal phenotype data collected, we copy the trait data (upper lethal temperature) associated with each sample into WGCNA_TraitData.csv file. 

This was be found in:  cp/gpfs1/cl/ecogen/pbio6800/Transcriptomics/enrichmentYou can cp it to your /mydata directory.

Then,we choose a set of soft-thresholding powers using the code chunk below.

Power <- c(c(1:10), seq(from = 12, to = 50, by = 2)) #calculate the networks by a variety of powers
sft <- pickSoftThreshold(norm.counts, 
                         powerVector = power,
                         networkType = "signed",
                         verbose = 5)

sft.data <-sft$fitIndices
#visualization to pick power

a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1) +
  geom_hline(yintercept = 0.8, color = 'red') +
  labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
  theme_classic()


a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1) +
  labs(x = 'Power', y = 'Mean Connectivity') +
  theme_classic()


grid.arrange(a1, a2, ncol = 2)

Then network construction was done using the code chunk below

# convert matrix to numeric
norm.counts[] <- sapply(norm.counts, as.numeric)
dim(norm.counts) # check dimensions: 
soft_power <- 18
temp_cor <- cor
cor <- WGCNA::cor


# memory estimate w.r.t blocksize
bwnet <- blockwiseModules(norm.counts,
                          maxBlockSize = 14000,
                          TOMType = "signed",
                          power = soft_power,
                          mergeCutHeight = 0.25,
                          numericLabels = FALSE,
                          randomSeed = 1234,
                          verbose = 3)

# This step takes a while so you can save it here for future work.
save(bwnet, file = "bwnet_results_WGCNA.RData")
load("bwnet_results_WGCNA.RData") #to load the bwnet file back in 

cor <- temp_cor

Then we Plot the dendrogram of modules using the following code chunk

module_eigengenes <- bwnet$MEs

# Print out a preview
head(module_eigengenes)

# get number of genes for each module
table(bwnet$colors)

#plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
                    c("unmerged", "merged"),
                    dendroLabels = FALSE,
                    addGuide = TRUE,
                    hang= 0.03,
                    guideHang = 0.05)
                    

Then we test for a correlation between each eigengene of each module and our ULT trait data

Finally, we plot the eigengene values by treatment and line conditions and look at what GO categories are present in any modules correlated with ULT




